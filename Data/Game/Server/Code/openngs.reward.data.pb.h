// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: openngs.reward.data.proto

#ifndef PROTOBUF_openngs_2ereward_2edata_2eproto__INCLUDED
#define PROTOBUF_openngs_2ereward_2edata_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3005001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
#include "openngs.core.pb.h"
#include "openngs.reward.common.pb.h"
// @@protoc_insertion_point(includes)

namespace protobuf_openngs_2ereward_2edata_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[12];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
void InitDefaultsRewardImpl();
void InitDefaultsReward();
void InitDefaultsRewardArrayImpl();
void InitDefaultsRewardArray();
void InitDefaultsRewardContentImpl();
void InitDefaultsRewardContent();
void InitDefaultsRewardContentArrayImpl();
void InitDefaultsRewardContentArray();
void InitDefaultsRewardConditionImpl();
void InitDefaultsRewardCondition();
void InitDefaultsRewardConditionArrayImpl();
void InitDefaultsRewardConditionArray();
void InitDefaultsRewardDataImpl();
void InitDefaultsRewardData();
void InitDefaultsRewardDataArrayImpl();
void InitDefaultsRewardDataArray();
void InitDefaultsRewardSaveDataImpl();
void InitDefaultsRewardSaveData();
void InitDefaultsRewardSaveDataArrayImpl();
void InitDefaultsRewardSaveDataArray();
void InitDefaultsRewardContainerImpl();
void InitDefaultsRewardContainer();
void InitDefaultsRewardContainerArrayImpl();
void InitDefaultsRewardContainerArray();
inline void InitDefaults() {
  InitDefaultsReward();
  InitDefaultsRewardArray();
  InitDefaultsRewardContent();
  InitDefaultsRewardContentArray();
  InitDefaultsRewardCondition();
  InitDefaultsRewardConditionArray();
  InitDefaultsRewardData();
  InitDefaultsRewardDataArray();
  InitDefaultsRewardSaveData();
  InitDefaultsRewardSaveDataArray();
  InitDefaultsRewardContainer();
  InitDefaultsRewardContainerArray();
}
}  // namespace protobuf_openngs_2ereward_2edata_2eproto
namespace OpenNGS {
namespace Reward {
namespace Data {
class Reward;
class RewardDefaultTypeInternal;
extern RewardDefaultTypeInternal _Reward_default_instance_;
class RewardArray;
class RewardArrayDefaultTypeInternal;
extern RewardArrayDefaultTypeInternal _RewardArray_default_instance_;
class RewardCondition;
class RewardConditionDefaultTypeInternal;
extern RewardConditionDefaultTypeInternal _RewardCondition_default_instance_;
class RewardConditionArray;
class RewardConditionArrayDefaultTypeInternal;
extern RewardConditionArrayDefaultTypeInternal _RewardConditionArray_default_instance_;
class RewardContainer;
class RewardContainerDefaultTypeInternal;
extern RewardContainerDefaultTypeInternal _RewardContainer_default_instance_;
class RewardContainerArray;
class RewardContainerArrayDefaultTypeInternal;
extern RewardContainerArrayDefaultTypeInternal _RewardContainerArray_default_instance_;
class RewardContent;
class RewardContentDefaultTypeInternal;
extern RewardContentDefaultTypeInternal _RewardContent_default_instance_;
class RewardContentArray;
class RewardContentArrayDefaultTypeInternal;
extern RewardContentArrayDefaultTypeInternal _RewardContentArray_default_instance_;
class RewardData;
class RewardDataDefaultTypeInternal;
extern RewardDataDefaultTypeInternal _RewardData_default_instance_;
class RewardDataArray;
class RewardDataArrayDefaultTypeInternal;
extern RewardDataArrayDefaultTypeInternal _RewardDataArray_default_instance_;
class RewardSaveData;
class RewardSaveDataDefaultTypeInternal;
extern RewardSaveDataDefaultTypeInternal _RewardSaveData_default_instance_;
class RewardSaveDataArray;
class RewardSaveDataArrayDefaultTypeInternal;
extern RewardSaveDataArrayDefaultTypeInternal _RewardSaveDataArray_default_instance_;
}  // namespace Data
}  // namespace Reward
}  // namespace OpenNGS
namespace OpenNGS {
namespace Reward {
namespace Data {

// ===================================================================

class Reward : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:OpenNGS.Reward.Data.Reward) */ {
 public:
  Reward();
  virtual ~Reward();

  Reward(const Reward& from);

  inline Reward& operator=(const Reward& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Reward(Reward&& from) noexcept
    : Reward() {
    *this = ::std::move(from);
  }

  inline Reward& operator=(Reward&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Reward& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Reward* internal_default_instance() {
    return reinterpret_cast<const Reward*>(
               &_Reward_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(Reward* other);
  friend void swap(Reward& a, Reward& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Reward* New() const PROTOBUF_FINAL { return New(NULL); }

  Reward* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Reward& from);
  void MergeFrom(const Reward& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Reward* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .OpenNGS.Core.NGSText Name = 2;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 2;
  const ::OpenNGS::Core::NGSText& name() const;
  ::OpenNGS::Core::NGSText* release_name();
  ::OpenNGS::Core::NGSText* mutable_name();
  void set_allocated_name(::OpenNGS::Core::NGSText* name);

  // .OpenNGS.Core.NGSText Desc = 3;
  bool has_desc() const;
  void clear_desc();
  static const int kDescFieldNumber = 3;
  const ::OpenNGS::Core::NGSText& desc() const;
  ::OpenNGS::Core::NGSText* release_desc();
  ::OpenNGS::Core::NGSText* mutable_desc();
  void set_allocated_desc(::OpenNGS::Core::NGSText* desc);

  // uint32 Id = 1;
  void clear_id();
  static const int kIdFieldNumber = 1;
  ::google::protobuf::uint32 id() const;
  void set_id(::google::protobuf::uint32 value);

  // uint32 Condition = 4;
  void clear_condition();
  static const int kConditionFieldNumber = 4;
  ::google::protobuf::uint32 condition() const;
  void set_condition(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:OpenNGS.Reward.Data.Reward)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::OpenNGS::Core::NGSText* name_;
  ::OpenNGS::Core::NGSText* desc_;
  ::google::protobuf::uint32 id_;
  ::google::protobuf::uint32 condition_;
  mutable int _cached_size_;
  friend struct ::protobuf_openngs_2ereward_2edata_2eproto::TableStruct;
  friend void ::protobuf_openngs_2ereward_2edata_2eproto::InitDefaultsRewardImpl();
};
// -------------------------------------------------------------------

class RewardArray : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:OpenNGS.Reward.Data.RewardArray) */ {
 public:
  RewardArray();
  virtual ~RewardArray();

  RewardArray(const RewardArray& from);

  inline RewardArray& operator=(const RewardArray& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RewardArray(RewardArray&& from) noexcept
    : RewardArray() {
    *this = ::std::move(from);
  }

  inline RewardArray& operator=(RewardArray&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const RewardArray& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RewardArray* internal_default_instance() {
    return reinterpret_cast<const RewardArray*>(
               &_RewardArray_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void Swap(RewardArray* other);
  friend void swap(RewardArray& a, RewardArray& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RewardArray* New() const PROTOBUF_FINAL { return New(NULL); }

  RewardArray* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const RewardArray& from);
  void MergeFrom(const RewardArray& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(RewardArray* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .OpenNGS.Reward.Data.Reward items = 1;
  int items_size() const;
  void clear_items();
  static const int kItemsFieldNumber = 1;
  const ::OpenNGS::Reward::Data::Reward& items(int index) const;
  ::OpenNGS::Reward::Data::Reward* mutable_items(int index);
  ::OpenNGS::Reward::Data::Reward* add_items();
  ::google::protobuf::RepeatedPtrField< ::OpenNGS::Reward::Data::Reward >*
      mutable_items();
  const ::google::protobuf::RepeatedPtrField< ::OpenNGS::Reward::Data::Reward >&
      items() const;

  // @@protoc_insertion_point(class_scope:OpenNGS.Reward.Data.RewardArray)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::OpenNGS::Reward::Data::Reward > items_;
  mutable int _cached_size_;
  friend struct ::protobuf_openngs_2ereward_2edata_2eproto::TableStruct;
  friend void ::protobuf_openngs_2ereward_2edata_2eproto::InitDefaultsRewardArrayImpl();
};
// -------------------------------------------------------------------

class RewardContent : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:OpenNGS.Reward.Data.RewardContent) */ {
 public:
  RewardContent();
  virtual ~RewardContent();

  RewardContent(const RewardContent& from);

  inline RewardContent& operator=(const RewardContent& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RewardContent(RewardContent&& from) noexcept
    : RewardContent() {
    *this = ::std::move(from);
  }

  inline RewardContent& operator=(RewardContent&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const RewardContent& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RewardContent* internal_default_instance() {
    return reinterpret_cast<const RewardContent*>(
               &_RewardContent_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    2;

  void Swap(RewardContent* other);
  friend void swap(RewardContent& a, RewardContent& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RewardContent* New() const PROTOBUF_FINAL { return New(NULL); }

  RewardContent* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const RewardContent& from);
  void MergeFrom(const RewardContent& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(RewardContent* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .OpenNGS.Core.NGSText Decs = 2;
  bool has_decs() const;
  void clear_decs();
  static const int kDecsFieldNumber = 2;
  const ::OpenNGS::Core::NGSText& decs() const;
  ::OpenNGS::Core::NGSText* release_decs();
  ::OpenNGS::Core::NGSText* mutable_decs();
  void set_allocated_decs(::OpenNGS::Core::NGSText* decs);

  // uint32 Id = 1;
  void clear_id();
  static const int kIdFieldNumber = 1;
  ::google::protobuf::uint32 id() const;
  void set_id(::google::protobuf::uint32 value);

  // uint32 ItemID = 3;
  void clear_itemid();
  static const int kItemIDFieldNumber = 3;
  ::google::protobuf::uint32 itemid() const;
  void set_itemid(::google::protobuf::uint32 value);

  // uint32 ItemCount = 4;
  void clear_itemcount();
  static const int kItemCountFieldNumber = 4;
  ::google::protobuf::uint32 itemcount() const;
  void set_itemcount(::google::protobuf::uint32 value);

  // uint32 Condition = 5;
  void clear_condition();
  static const int kConditionFieldNumber = 5;
  ::google::protobuf::uint32 condition() const;
  void set_condition(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:OpenNGS.Reward.Data.RewardContent)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::OpenNGS::Core::NGSText* decs_;
  ::google::protobuf::uint32 id_;
  ::google::protobuf::uint32 itemid_;
  ::google::protobuf::uint32 itemcount_;
  ::google::protobuf::uint32 condition_;
  mutable int _cached_size_;
  friend struct ::protobuf_openngs_2ereward_2edata_2eproto::TableStruct;
  friend void ::protobuf_openngs_2ereward_2edata_2eproto::InitDefaultsRewardContentImpl();
};
// -------------------------------------------------------------------

class RewardContentArray : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:OpenNGS.Reward.Data.RewardContentArray) */ {
 public:
  RewardContentArray();
  virtual ~RewardContentArray();

  RewardContentArray(const RewardContentArray& from);

  inline RewardContentArray& operator=(const RewardContentArray& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RewardContentArray(RewardContentArray&& from) noexcept
    : RewardContentArray() {
    *this = ::std::move(from);
  }

  inline RewardContentArray& operator=(RewardContentArray&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const RewardContentArray& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RewardContentArray* internal_default_instance() {
    return reinterpret_cast<const RewardContentArray*>(
               &_RewardContentArray_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    3;

  void Swap(RewardContentArray* other);
  friend void swap(RewardContentArray& a, RewardContentArray& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RewardContentArray* New() const PROTOBUF_FINAL { return New(NULL); }

  RewardContentArray* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const RewardContentArray& from);
  void MergeFrom(const RewardContentArray& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(RewardContentArray* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .OpenNGS.Reward.Data.RewardContent items = 1;
  int items_size() const;
  void clear_items();
  static const int kItemsFieldNumber = 1;
  const ::OpenNGS::Reward::Data::RewardContent& items(int index) const;
  ::OpenNGS::Reward::Data::RewardContent* mutable_items(int index);
  ::OpenNGS::Reward::Data::RewardContent* add_items();
  ::google::protobuf::RepeatedPtrField< ::OpenNGS::Reward::Data::RewardContent >*
      mutable_items();
  const ::google::protobuf::RepeatedPtrField< ::OpenNGS::Reward::Data::RewardContent >&
      items() const;

  // @@protoc_insertion_point(class_scope:OpenNGS.Reward.Data.RewardContentArray)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::OpenNGS::Reward::Data::RewardContent > items_;
  mutable int _cached_size_;
  friend struct ::protobuf_openngs_2ereward_2edata_2eproto::TableStruct;
  friend void ::protobuf_openngs_2ereward_2edata_2eproto::InitDefaultsRewardContentArrayImpl();
};
// -------------------------------------------------------------------

class RewardCondition : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:OpenNGS.Reward.Data.RewardCondition) */ {
 public:
  RewardCondition();
  virtual ~RewardCondition();

  RewardCondition(const RewardCondition& from);

  inline RewardCondition& operator=(const RewardCondition& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RewardCondition(RewardCondition&& from) noexcept
    : RewardCondition() {
    *this = ::std::move(from);
  }

  inline RewardCondition& operator=(RewardCondition&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const RewardCondition& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RewardCondition* internal_default_instance() {
    return reinterpret_cast<const RewardCondition*>(
               &_RewardCondition_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    4;

  void Swap(RewardCondition* other);
  friend void swap(RewardCondition& a, RewardCondition& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RewardCondition* New() const PROTOBUF_FINAL { return New(NULL); }

  RewardCondition* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const RewardCondition& from);
  void MergeFrom(const RewardCondition& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(RewardCondition* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint32 Id = 1;
  void clear_id();
  static const int kIdFieldNumber = 1;
  ::google::protobuf::uint32 id() const;
  void set_id(::google::protobuf::uint32 value);

  // uint32 ZoneId = 2;
  void clear_zoneid();
  static const int kZoneIdFieldNumber = 2;
  ::google::protobuf::uint32 zoneid() const;
  void set_zoneid(::google::protobuf::uint32 value);

  // uint32 ServerId = 3;
  void clear_serverid();
  static const int kServerIdFieldNumber = 3;
  ::google::protobuf::uint32 serverid() const;
  void set_serverid(::google::protobuf::uint32 value);

  // uint32 SeasonId = 4;
  void clear_seasonid();
  static const int kSeasonIdFieldNumber = 4;
  ::google::protobuf::uint32 seasonid() const;
  void set_seasonid(::google::protobuf::uint32 value);

  // uint32 ObtainCountLimit = 5;
  void clear_obtaincountlimit();
  static const int kObtainCountLimitFieldNumber = 5;
  ::google::protobuf::uint32 obtaincountlimit() const;
  void set_obtaincountlimit(::google::protobuf::uint32 value);

  // uint32 ValidTime = 6;
  void clear_validtime();
  static const int kValidTimeFieldNumber = 6;
  ::google::protobuf::uint32 validtime() const;
  void set_validtime(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:OpenNGS.Reward.Data.RewardCondition)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 id_;
  ::google::protobuf::uint32 zoneid_;
  ::google::protobuf::uint32 serverid_;
  ::google::protobuf::uint32 seasonid_;
  ::google::protobuf::uint32 obtaincountlimit_;
  ::google::protobuf::uint32 validtime_;
  mutable int _cached_size_;
  friend struct ::protobuf_openngs_2ereward_2edata_2eproto::TableStruct;
  friend void ::protobuf_openngs_2ereward_2edata_2eproto::InitDefaultsRewardConditionImpl();
};
// -------------------------------------------------------------------

class RewardConditionArray : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:OpenNGS.Reward.Data.RewardConditionArray) */ {
 public:
  RewardConditionArray();
  virtual ~RewardConditionArray();

  RewardConditionArray(const RewardConditionArray& from);

  inline RewardConditionArray& operator=(const RewardConditionArray& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RewardConditionArray(RewardConditionArray&& from) noexcept
    : RewardConditionArray() {
    *this = ::std::move(from);
  }

  inline RewardConditionArray& operator=(RewardConditionArray&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const RewardConditionArray& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RewardConditionArray* internal_default_instance() {
    return reinterpret_cast<const RewardConditionArray*>(
               &_RewardConditionArray_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    5;

  void Swap(RewardConditionArray* other);
  friend void swap(RewardConditionArray& a, RewardConditionArray& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RewardConditionArray* New() const PROTOBUF_FINAL { return New(NULL); }

  RewardConditionArray* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const RewardConditionArray& from);
  void MergeFrom(const RewardConditionArray& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(RewardConditionArray* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .OpenNGS.Reward.Data.RewardCondition items = 1;
  int items_size() const;
  void clear_items();
  static const int kItemsFieldNumber = 1;
  const ::OpenNGS::Reward::Data::RewardCondition& items(int index) const;
  ::OpenNGS::Reward::Data::RewardCondition* mutable_items(int index);
  ::OpenNGS::Reward::Data::RewardCondition* add_items();
  ::google::protobuf::RepeatedPtrField< ::OpenNGS::Reward::Data::RewardCondition >*
      mutable_items();
  const ::google::protobuf::RepeatedPtrField< ::OpenNGS::Reward::Data::RewardCondition >&
      items() const;

  // @@protoc_insertion_point(class_scope:OpenNGS.Reward.Data.RewardConditionArray)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::OpenNGS::Reward::Data::RewardCondition > items_;
  mutable int _cached_size_;
  friend struct ::protobuf_openngs_2ereward_2edata_2eproto::TableStruct;
  friend void ::protobuf_openngs_2ereward_2edata_2eproto::InitDefaultsRewardConditionArrayImpl();
};
// -------------------------------------------------------------------

class RewardData : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:OpenNGS.Reward.Data.RewardData) */ {
 public:
  RewardData();
  virtual ~RewardData();

  RewardData(const RewardData& from);

  inline RewardData& operator=(const RewardData& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RewardData(RewardData&& from) noexcept
    : RewardData() {
    *this = ::std::move(from);
  }

  inline RewardData& operator=(RewardData&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const RewardData& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RewardData* internal_default_instance() {
    return reinterpret_cast<const RewardData*>(
               &_RewardData_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    6;

  void Swap(RewardData* other);
  friend void swap(RewardData& a, RewardData& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RewardData* New() const PROTOBUF_FINAL { return New(NULL); }

  RewardData* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const RewardData& from);
  void MergeFrom(const RewardData& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(RewardData* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint32 Id = 1;
  void clear_id();
  static const int kIdFieldNumber = 1;
  ::google::protobuf::uint32 id() const;
  void set_id(::google::protobuf::uint32 value);

  // uint32 ItemID = 2;
  void clear_itemid();
  static const int kItemIDFieldNumber = 2;
  ::google::protobuf::uint32 itemid() const;
  void set_itemid(::google::protobuf::uint32 value);

  // uint32 ItemCount = 3;
  void clear_itemcount();
  static const int kItemCountFieldNumber = 3;
  ::google::protobuf::uint32 itemcount() const;
  void set_itemcount(::google::protobuf::uint32 value);

  // .OpenNGS.Reward.Common.REWARDSTAT_TYPE Status = 4;
  void clear_status();
  static const int kStatusFieldNumber = 4;
  ::OpenNGS::Reward::Common::REWARDSTAT_TYPE status() const;
  void set_status(::OpenNGS::Reward::Common::REWARDSTAT_TYPE value);

  // @@protoc_insertion_point(class_scope:OpenNGS.Reward.Data.RewardData)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 id_;
  ::google::protobuf::uint32 itemid_;
  ::google::protobuf::uint32 itemcount_;
  int status_;
  mutable int _cached_size_;
  friend struct ::protobuf_openngs_2ereward_2edata_2eproto::TableStruct;
  friend void ::protobuf_openngs_2ereward_2edata_2eproto::InitDefaultsRewardDataImpl();
};
// -------------------------------------------------------------------

class RewardDataArray : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:OpenNGS.Reward.Data.RewardDataArray) */ {
 public:
  RewardDataArray();
  virtual ~RewardDataArray();

  RewardDataArray(const RewardDataArray& from);

  inline RewardDataArray& operator=(const RewardDataArray& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RewardDataArray(RewardDataArray&& from) noexcept
    : RewardDataArray() {
    *this = ::std::move(from);
  }

  inline RewardDataArray& operator=(RewardDataArray&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const RewardDataArray& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RewardDataArray* internal_default_instance() {
    return reinterpret_cast<const RewardDataArray*>(
               &_RewardDataArray_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    7;

  void Swap(RewardDataArray* other);
  friend void swap(RewardDataArray& a, RewardDataArray& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RewardDataArray* New() const PROTOBUF_FINAL { return New(NULL); }

  RewardDataArray* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const RewardDataArray& from);
  void MergeFrom(const RewardDataArray& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(RewardDataArray* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .OpenNGS.Reward.Data.RewardData items = 1;
  int items_size() const;
  void clear_items();
  static const int kItemsFieldNumber = 1;
  const ::OpenNGS::Reward::Data::RewardData& items(int index) const;
  ::OpenNGS::Reward::Data::RewardData* mutable_items(int index);
  ::OpenNGS::Reward::Data::RewardData* add_items();
  ::google::protobuf::RepeatedPtrField< ::OpenNGS::Reward::Data::RewardData >*
      mutable_items();
  const ::google::protobuf::RepeatedPtrField< ::OpenNGS::Reward::Data::RewardData >&
      items() const;

  // @@protoc_insertion_point(class_scope:OpenNGS.Reward.Data.RewardDataArray)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::OpenNGS::Reward::Data::RewardData > items_;
  mutable int _cached_size_;
  friend struct ::protobuf_openngs_2ereward_2edata_2eproto::TableStruct;
  friend void ::protobuf_openngs_2ereward_2edata_2eproto::InitDefaultsRewardDataArrayImpl();
};
// -------------------------------------------------------------------

class RewardSaveData : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:OpenNGS.Reward.Data.RewardSaveData) */ {
 public:
  RewardSaveData();
  virtual ~RewardSaveData();

  RewardSaveData(const RewardSaveData& from);

  inline RewardSaveData& operator=(const RewardSaveData& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RewardSaveData(RewardSaveData&& from) noexcept
    : RewardSaveData() {
    *this = ::std::move(from);
  }

  inline RewardSaveData& operator=(RewardSaveData&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const RewardSaveData& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RewardSaveData* internal_default_instance() {
    return reinterpret_cast<const RewardSaveData*>(
               &_RewardSaveData_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    8;

  void Swap(RewardSaveData* other);
  friend void swap(RewardSaveData& a, RewardSaveData& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RewardSaveData* New() const PROTOBUF_FINAL { return New(NULL); }

  RewardSaveData* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const RewardSaveData& from);
  void MergeFrom(const RewardSaveData& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(RewardSaveData* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint32 Id = 1;
  void clear_id();
  static const int kIdFieldNumber = 1;
  ::google::protobuf::uint32 id() const;
  void set_id(::google::protobuf::uint32 value);

  // uint32 ReceiveCount = 2;
  void clear_receivecount();
  static const int kReceiveCountFieldNumber = 2;
  ::google::protobuf::uint32 receivecount() const;
  void set_receivecount(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:OpenNGS.Reward.Data.RewardSaveData)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 id_;
  ::google::protobuf::uint32 receivecount_;
  mutable int _cached_size_;
  friend struct ::protobuf_openngs_2ereward_2edata_2eproto::TableStruct;
  friend void ::protobuf_openngs_2ereward_2edata_2eproto::InitDefaultsRewardSaveDataImpl();
};
// -------------------------------------------------------------------

class RewardSaveDataArray : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:OpenNGS.Reward.Data.RewardSaveDataArray) */ {
 public:
  RewardSaveDataArray();
  virtual ~RewardSaveDataArray();

  RewardSaveDataArray(const RewardSaveDataArray& from);

  inline RewardSaveDataArray& operator=(const RewardSaveDataArray& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RewardSaveDataArray(RewardSaveDataArray&& from) noexcept
    : RewardSaveDataArray() {
    *this = ::std::move(from);
  }

  inline RewardSaveDataArray& operator=(RewardSaveDataArray&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const RewardSaveDataArray& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RewardSaveDataArray* internal_default_instance() {
    return reinterpret_cast<const RewardSaveDataArray*>(
               &_RewardSaveDataArray_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    9;

  void Swap(RewardSaveDataArray* other);
  friend void swap(RewardSaveDataArray& a, RewardSaveDataArray& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RewardSaveDataArray* New() const PROTOBUF_FINAL { return New(NULL); }

  RewardSaveDataArray* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const RewardSaveDataArray& from);
  void MergeFrom(const RewardSaveDataArray& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(RewardSaveDataArray* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .OpenNGS.Reward.Data.RewardSaveData items = 1;
  int items_size() const;
  void clear_items();
  static const int kItemsFieldNumber = 1;
  const ::OpenNGS::Reward::Data::RewardSaveData& items(int index) const;
  ::OpenNGS::Reward::Data::RewardSaveData* mutable_items(int index);
  ::OpenNGS::Reward::Data::RewardSaveData* add_items();
  ::google::protobuf::RepeatedPtrField< ::OpenNGS::Reward::Data::RewardSaveData >*
      mutable_items();
  const ::google::protobuf::RepeatedPtrField< ::OpenNGS::Reward::Data::RewardSaveData >&
      items() const;

  // @@protoc_insertion_point(class_scope:OpenNGS.Reward.Data.RewardSaveDataArray)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::OpenNGS::Reward::Data::RewardSaveData > items_;
  mutable int _cached_size_;
  friend struct ::protobuf_openngs_2ereward_2edata_2eproto::TableStruct;
  friend void ::protobuf_openngs_2ereward_2edata_2eproto::InitDefaultsRewardSaveDataArrayImpl();
};
// -------------------------------------------------------------------

class RewardContainer : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:OpenNGS.Reward.Data.RewardContainer) */ {
 public:
  RewardContainer();
  virtual ~RewardContainer();

  RewardContainer(const RewardContainer& from);

  inline RewardContainer& operator=(const RewardContainer& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RewardContainer(RewardContainer&& from) noexcept
    : RewardContainer() {
    *this = ::std::move(from);
  }

  inline RewardContainer& operator=(RewardContainer&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const RewardContainer& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RewardContainer* internal_default_instance() {
    return reinterpret_cast<const RewardContainer*>(
               &_RewardContainer_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    10;

  void Swap(RewardContainer* other);
  friend void swap(RewardContainer& a, RewardContainer& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RewardContainer* New() const PROTOBUF_FINAL { return New(NULL); }

  RewardContainer* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const RewardContainer& from);
  void MergeFrom(const RewardContainer& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(RewardContainer* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .OpenNGS.Reward.Data.RewardSaveData rewardDict = 1;
  int rewarddict_size() const;
  void clear_rewarddict();
  static const int kRewardDictFieldNumber = 1;
  const ::OpenNGS::Reward::Data::RewardSaveData& rewarddict(int index) const;
  ::OpenNGS::Reward::Data::RewardSaveData* mutable_rewarddict(int index);
  ::OpenNGS::Reward::Data::RewardSaveData* add_rewarddict();
  ::google::protobuf::RepeatedPtrField< ::OpenNGS::Reward::Data::RewardSaveData >*
      mutable_rewarddict();
  const ::google::protobuf::RepeatedPtrField< ::OpenNGS::Reward::Data::RewardSaveData >&
      rewarddict() const;

  // @@protoc_insertion_point(class_scope:OpenNGS.Reward.Data.RewardContainer)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::OpenNGS::Reward::Data::RewardSaveData > rewarddict_;
  mutable int _cached_size_;
  friend struct ::protobuf_openngs_2ereward_2edata_2eproto::TableStruct;
  friend void ::protobuf_openngs_2ereward_2edata_2eproto::InitDefaultsRewardContainerImpl();
};
// -------------------------------------------------------------------

class RewardContainerArray : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:OpenNGS.Reward.Data.RewardContainerArray) */ {
 public:
  RewardContainerArray();
  virtual ~RewardContainerArray();

  RewardContainerArray(const RewardContainerArray& from);

  inline RewardContainerArray& operator=(const RewardContainerArray& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RewardContainerArray(RewardContainerArray&& from) noexcept
    : RewardContainerArray() {
    *this = ::std::move(from);
  }

  inline RewardContainerArray& operator=(RewardContainerArray&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const RewardContainerArray& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RewardContainerArray* internal_default_instance() {
    return reinterpret_cast<const RewardContainerArray*>(
               &_RewardContainerArray_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    11;

  void Swap(RewardContainerArray* other);
  friend void swap(RewardContainerArray& a, RewardContainerArray& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RewardContainerArray* New() const PROTOBUF_FINAL { return New(NULL); }

  RewardContainerArray* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const RewardContainerArray& from);
  void MergeFrom(const RewardContainerArray& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(RewardContainerArray* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .OpenNGS.Reward.Data.RewardContainer items = 1;
  int items_size() const;
  void clear_items();
  static const int kItemsFieldNumber = 1;
  const ::OpenNGS::Reward::Data::RewardContainer& items(int index) const;
  ::OpenNGS::Reward::Data::RewardContainer* mutable_items(int index);
  ::OpenNGS::Reward::Data::RewardContainer* add_items();
  ::google::protobuf::RepeatedPtrField< ::OpenNGS::Reward::Data::RewardContainer >*
      mutable_items();
  const ::google::protobuf::RepeatedPtrField< ::OpenNGS::Reward::Data::RewardContainer >&
      items() const;

  // @@protoc_insertion_point(class_scope:OpenNGS.Reward.Data.RewardContainerArray)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::OpenNGS::Reward::Data::RewardContainer > items_;
  mutable int _cached_size_;
  friend struct ::protobuf_openngs_2ereward_2edata_2eproto::TableStruct;
  friend void ::protobuf_openngs_2ereward_2edata_2eproto::InitDefaultsRewardContainerArrayImpl();
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Reward

// uint32 Id = 1;
inline void Reward::clear_id() {
  id_ = 0u;
}
inline ::google::protobuf::uint32 Reward::id() const {
  // @@protoc_insertion_point(field_get:OpenNGS.Reward.Data.Reward.Id)
  return id_;
}
inline void Reward::set_id(::google::protobuf::uint32 value) {
  
  id_ = value;
  // @@protoc_insertion_point(field_set:OpenNGS.Reward.Data.Reward.Id)
}

// .OpenNGS.Core.NGSText Name = 2;
inline bool Reward::has_name() const {
  return this != internal_default_instance() && name_ != NULL;
}
inline const ::OpenNGS::Core::NGSText& Reward::name() const {
  const ::OpenNGS::Core::NGSText* p = name_;
  // @@protoc_insertion_point(field_get:OpenNGS.Reward.Data.Reward.Name)
  return p != NULL ? *p : *reinterpret_cast<const ::OpenNGS::Core::NGSText*>(
      &::OpenNGS::Core::_NGSText_default_instance_);
}
inline ::OpenNGS::Core::NGSText* Reward::release_name() {
  // @@protoc_insertion_point(field_release:OpenNGS.Reward.Data.Reward.Name)
  
  ::OpenNGS::Core::NGSText* temp = name_;
  name_ = NULL;
  return temp;
}
inline ::OpenNGS::Core::NGSText* Reward::mutable_name() {
  
  if (name_ == NULL) {
    name_ = new ::OpenNGS::Core::NGSText;
  }
  // @@protoc_insertion_point(field_mutable:OpenNGS.Reward.Data.Reward.Name)
  return name_;
}
inline void Reward::set_allocated_name(::OpenNGS::Core::NGSText* name) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(name_);
  }
  if (name) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      name = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, name, submessage_arena);
    }
    
  } else {
    
  }
  name_ = name;
  // @@protoc_insertion_point(field_set_allocated:OpenNGS.Reward.Data.Reward.Name)
}

// .OpenNGS.Core.NGSText Desc = 3;
inline bool Reward::has_desc() const {
  return this != internal_default_instance() && desc_ != NULL;
}
inline const ::OpenNGS::Core::NGSText& Reward::desc() const {
  const ::OpenNGS::Core::NGSText* p = desc_;
  // @@protoc_insertion_point(field_get:OpenNGS.Reward.Data.Reward.Desc)
  return p != NULL ? *p : *reinterpret_cast<const ::OpenNGS::Core::NGSText*>(
      &::OpenNGS::Core::_NGSText_default_instance_);
}
inline ::OpenNGS::Core::NGSText* Reward::release_desc() {
  // @@protoc_insertion_point(field_release:OpenNGS.Reward.Data.Reward.Desc)
  
  ::OpenNGS::Core::NGSText* temp = desc_;
  desc_ = NULL;
  return temp;
}
inline ::OpenNGS::Core::NGSText* Reward::mutable_desc() {
  
  if (desc_ == NULL) {
    desc_ = new ::OpenNGS::Core::NGSText;
  }
  // @@protoc_insertion_point(field_mutable:OpenNGS.Reward.Data.Reward.Desc)
  return desc_;
}
inline void Reward::set_allocated_desc(::OpenNGS::Core::NGSText* desc) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(desc_);
  }
  if (desc) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      desc = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, desc, submessage_arena);
    }
    
  } else {
    
  }
  desc_ = desc;
  // @@protoc_insertion_point(field_set_allocated:OpenNGS.Reward.Data.Reward.Desc)
}

// uint32 Condition = 4;
inline void Reward::clear_condition() {
  condition_ = 0u;
}
inline ::google::protobuf::uint32 Reward::condition() const {
  // @@protoc_insertion_point(field_get:OpenNGS.Reward.Data.Reward.Condition)
  return condition_;
}
inline void Reward::set_condition(::google::protobuf::uint32 value) {
  
  condition_ = value;
  // @@protoc_insertion_point(field_set:OpenNGS.Reward.Data.Reward.Condition)
}

// -------------------------------------------------------------------

// RewardArray

// repeated .OpenNGS.Reward.Data.Reward items = 1;
inline int RewardArray::items_size() const {
  return items_.size();
}
inline void RewardArray::clear_items() {
  items_.Clear();
}
inline const ::OpenNGS::Reward::Data::Reward& RewardArray::items(int index) const {
  // @@protoc_insertion_point(field_get:OpenNGS.Reward.Data.RewardArray.items)
  return items_.Get(index);
}
inline ::OpenNGS::Reward::Data::Reward* RewardArray::mutable_items(int index) {
  // @@protoc_insertion_point(field_mutable:OpenNGS.Reward.Data.RewardArray.items)
  return items_.Mutable(index);
}
inline ::OpenNGS::Reward::Data::Reward* RewardArray::add_items() {
  // @@protoc_insertion_point(field_add:OpenNGS.Reward.Data.RewardArray.items)
  return items_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::OpenNGS::Reward::Data::Reward >*
RewardArray::mutable_items() {
  // @@protoc_insertion_point(field_mutable_list:OpenNGS.Reward.Data.RewardArray.items)
  return &items_;
}
inline const ::google::protobuf::RepeatedPtrField< ::OpenNGS::Reward::Data::Reward >&
RewardArray::items() const {
  // @@protoc_insertion_point(field_list:OpenNGS.Reward.Data.RewardArray.items)
  return items_;
}

// -------------------------------------------------------------------

// RewardContent

// uint32 Id = 1;
inline void RewardContent::clear_id() {
  id_ = 0u;
}
inline ::google::protobuf::uint32 RewardContent::id() const {
  // @@protoc_insertion_point(field_get:OpenNGS.Reward.Data.RewardContent.Id)
  return id_;
}
inline void RewardContent::set_id(::google::protobuf::uint32 value) {
  
  id_ = value;
  // @@protoc_insertion_point(field_set:OpenNGS.Reward.Data.RewardContent.Id)
}

// .OpenNGS.Core.NGSText Decs = 2;
inline bool RewardContent::has_decs() const {
  return this != internal_default_instance() && decs_ != NULL;
}
inline const ::OpenNGS::Core::NGSText& RewardContent::decs() const {
  const ::OpenNGS::Core::NGSText* p = decs_;
  // @@protoc_insertion_point(field_get:OpenNGS.Reward.Data.RewardContent.Decs)
  return p != NULL ? *p : *reinterpret_cast<const ::OpenNGS::Core::NGSText*>(
      &::OpenNGS::Core::_NGSText_default_instance_);
}
inline ::OpenNGS::Core::NGSText* RewardContent::release_decs() {
  // @@protoc_insertion_point(field_release:OpenNGS.Reward.Data.RewardContent.Decs)
  
  ::OpenNGS::Core::NGSText* temp = decs_;
  decs_ = NULL;
  return temp;
}
inline ::OpenNGS::Core::NGSText* RewardContent::mutable_decs() {
  
  if (decs_ == NULL) {
    decs_ = new ::OpenNGS::Core::NGSText;
  }
  // @@protoc_insertion_point(field_mutable:OpenNGS.Reward.Data.RewardContent.Decs)
  return decs_;
}
inline void RewardContent::set_allocated_decs(::OpenNGS::Core::NGSText* decs) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(decs_);
  }
  if (decs) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      decs = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, decs, submessage_arena);
    }
    
  } else {
    
  }
  decs_ = decs;
  // @@protoc_insertion_point(field_set_allocated:OpenNGS.Reward.Data.RewardContent.Decs)
}

// uint32 ItemID = 3;
inline void RewardContent::clear_itemid() {
  itemid_ = 0u;
}
inline ::google::protobuf::uint32 RewardContent::itemid() const {
  // @@protoc_insertion_point(field_get:OpenNGS.Reward.Data.RewardContent.ItemID)
  return itemid_;
}
inline void RewardContent::set_itemid(::google::protobuf::uint32 value) {
  
  itemid_ = value;
  // @@protoc_insertion_point(field_set:OpenNGS.Reward.Data.RewardContent.ItemID)
}

// uint32 ItemCount = 4;
inline void RewardContent::clear_itemcount() {
  itemcount_ = 0u;
}
inline ::google::protobuf::uint32 RewardContent::itemcount() const {
  // @@protoc_insertion_point(field_get:OpenNGS.Reward.Data.RewardContent.ItemCount)
  return itemcount_;
}
inline void RewardContent::set_itemcount(::google::protobuf::uint32 value) {
  
  itemcount_ = value;
  // @@protoc_insertion_point(field_set:OpenNGS.Reward.Data.RewardContent.ItemCount)
}

// uint32 Condition = 5;
inline void RewardContent::clear_condition() {
  condition_ = 0u;
}
inline ::google::protobuf::uint32 RewardContent::condition() const {
  // @@protoc_insertion_point(field_get:OpenNGS.Reward.Data.RewardContent.Condition)
  return condition_;
}
inline void RewardContent::set_condition(::google::protobuf::uint32 value) {
  
  condition_ = value;
  // @@protoc_insertion_point(field_set:OpenNGS.Reward.Data.RewardContent.Condition)
}

// -------------------------------------------------------------------

// RewardContentArray

// repeated .OpenNGS.Reward.Data.RewardContent items = 1;
inline int RewardContentArray::items_size() const {
  return items_.size();
}
inline void RewardContentArray::clear_items() {
  items_.Clear();
}
inline const ::OpenNGS::Reward::Data::RewardContent& RewardContentArray::items(int index) const {
  // @@protoc_insertion_point(field_get:OpenNGS.Reward.Data.RewardContentArray.items)
  return items_.Get(index);
}
inline ::OpenNGS::Reward::Data::RewardContent* RewardContentArray::mutable_items(int index) {
  // @@protoc_insertion_point(field_mutable:OpenNGS.Reward.Data.RewardContentArray.items)
  return items_.Mutable(index);
}
inline ::OpenNGS::Reward::Data::RewardContent* RewardContentArray::add_items() {
  // @@protoc_insertion_point(field_add:OpenNGS.Reward.Data.RewardContentArray.items)
  return items_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::OpenNGS::Reward::Data::RewardContent >*
RewardContentArray::mutable_items() {
  // @@protoc_insertion_point(field_mutable_list:OpenNGS.Reward.Data.RewardContentArray.items)
  return &items_;
}
inline const ::google::protobuf::RepeatedPtrField< ::OpenNGS::Reward::Data::RewardContent >&
RewardContentArray::items() const {
  // @@protoc_insertion_point(field_list:OpenNGS.Reward.Data.RewardContentArray.items)
  return items_;
}

// -------------------------------------------------------------------

// RewardCondition

// uint32 Id = 1;
inline void RewardCondition::clear_id() {
  id_ = 0u;
}
inline ::google::protobuf::uint32 RewardCondition::id() const {
  // @@protoc_insertion_point(field_get:OpenNGS.Reward.Data.RewardCondition.Id)
  return id_;
}
inline void RewardCondition::set_id(::google::protobuf::uint32 value) {
  
  id_ = value;
  // @@protoc_insertion_point(field_set:OpenNGS.Reward.Data.RewardCondition.Id)
}

// uint32 ZoneId = 2;
inline void RewardCondition::clear_zoneid() {
  zoneid_ = 0u;
}
inline ::google::protobuf::uint32 RewardCondition::zoneid() const {
  // @@protoc_insertion_point(field_get:OpenNGS.Reward.Data.RewardCondition.ZoneId)
  return zoneid_;
}
inline void RewardCondition::set_zoneid(::google::protobuf::uint32 value) {
  
  zoneid_ = value;
  // @@protoc_insertion_point(field_set:OpenNGS.Reward.Data.RewardCondition.ZoneId)
}

// uint32 ServerId = 3;
inline void RewardCondition::clear_serverid() {
  serverid_ = 0u;
}
inline ::google::protobuf::uint32 RewardCondition::serverid() const {
  // @@protoc_insertion_point(field_get:OpenNGS.Reward.Data.RewardCondition.ServerId)
  return serverid_;
}
inline void RewardCondition::set_serverid(::google::protobuf::uint32 value) {
  
  serverid_ = value;
  // @@protoc_insertion_point(field_set:OpenNGS.Reward.Data.RewardCondition.ServerId)
}

// uint32 SeasonId = 4;
inline void RewardCondition::clear_seasonid() {
  seasonid_ = 0u;
}
inline ::google::protobuf::uint32 RewardCondition::seasonid() const {
  // @@protoc_insertion_point(field_get:OpenNGS.Reward.Data.RewardCondition.SeasonId)
  return seasonid_;
}
inline void RewardCondition::set_seasonid(::google::protobuf::uint32 value) {
  
  seasonid_ = value;
  // @@protoc_insertion_point(field_set:OpenNGS.Reward.Data.RewardCondition.SeasonId)
}

// uint32 ObtainCountLimit = 5;
inline void RewardCondition::clear_obtaincountlimit() {
  obtaincountlimit_ = 0u;
}
inline ::google::protobuf::uint32 RewardCondition::obtaincountlimit() const {
  // @@protoc_insertion_point(field_get:OpenNGS.Reward.Data.RewardCondition.ObtainCountLimit)
  return obtaincountlimit_;
}
inline void RewardCondition::set_obtaincountlimit(::google::protobuf::uint32 value) {
  
  obtaincountlimit_ = value;
  // @@protoc_insertion_point(field_set:OpenNGS.Reward.Data.RewardCondition.ObtainCountLimit)
}

// uint32 ValidTime = 6;
inline void RewardCondition::clear_validtime() {
  validtime_ = 0u;
}
inline ::google::protobuf::uint32 RewardCondition::validtime() const {
  // @@protoc_insertion_point(field_get:OpenNGS.Reward.Data.RewardCondition.ValidTime)
  return validtime_;
}
inline void RewardCondition::set_validtime(::google::protobuf::uint32 value) {
  
  validtime_ = value;
  // @@protoc_insertion_point(field_set:OpenNGS.Reward.Data.RewardCondition.ValidTime)
}

// -------------------------------------------------------------------

// RewardConditionArray

// repeated .OpenNGS.Reward.Data.RewardCondition items = 1;
inline int RewardConditionArray::items_size() const {
  return items_.size();
}
inline void RewardConditionArray::clear_items() {
  items_.Clear();
}
inline const ::OpenNGS::Reward::Data::RewardCondition& RewardConditionArray::items(int index) const {
  // @@protoc_insertion_point(field_get:OpenNGS.Reward.Data.RewardConditionArray.items)
  return items_.Get(index);
}
inline ::OpenNGS::Reward::Data::RewardCondition* RewardConditionArray::mutable_items(int index) {
  // @@protoc_insertion_point(field_mutable:OpenNGS.Reward.Data.RewardConditionArray.items)
  return items_.Mutable(index);
}
inline ::OpenNGS::Reward::Data::RewardCondition* RewardConditionArray::add_items() {
  // @@protoc_insertion_point(field_add:OpenNGS.Reward.Data.RewardConditionArray.items)
  return items_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::OpenNGS::Reward::Data::RewardCondition >*
RewardConditionArray::mutable_items() {
  // @@protoc_insertion_point(field_mutable_list:OpenNGS.Reward.Data.RewardConditionArray.items)
  return &items_;
}
inline const ::google::protobuf::RepeatedPtrField< ::OpenNGS::Reward::Data::RewardCondition >&
RewardConditionArray::items() const {
  // @@protoc_insertion_point(field_list:OpenNGS.Reward.Data.RewardConditionArray.items)
  return items_;
}

// -------------------------------------------------------------------

// RewardData

// uint32 Id = 1;
inline void RewardData::clear_id() {
  id_ = 0u;
}
inline ::google::protobuf::uint32 RewardData::id() const {
  // @@protoc_insertion_point(field_get:OpenNGS.Reward.Data.RewardData.Id)
  return id_;
}
inline void RewardData::set_id(::google::protobuf::uint32 value) {
  
  id_ = value;
  // @@protoc_insertion_point(field_set:OpenNGS.Reward.Data.RewardData.Id)
}

// uint32 ItemID = 2;
inline void RewardData::clear_itemid() {
  itemid_ = 0u;
}
inline ::google::protobuf::uint32 RewardData::itemid() const {
  // @@protoc_insertion_point(field_get:OpenNGS.Reward.Data.RewardData.ItemID)
  return itemid_;
}
inline void RewardData::set_itemid(::google::protobuf::uint32 value) {
  
  itemid_ = value;
  // @@protoc_insertion_point(field_set:OpenNGS.Reward.Data.RewardData.ItemID)
}

// uint32 ItemCount = 3;
inline void RewardData::clear_itemcount() {
  itemcount_ = 0u;
}
inline ::google::protobuf::uint32 RewardData::itemcount() const {
  // @@protoc_insertion_point(field_get:OpenNGS.Reward.Data.RewardData.ItemCount)
  return itemcount_;
}
inline void RewardData::set_itemcount(::google::protobuf::uint32 value) {
  
  itemcount_ = value;
  // @@protoc_insertion_point(field_set:OpenNGS.Reward.Data.RewardData.ItemCount)
}

// .OpenNGS.Reward.Common.REWARDSTAT_TYPE Status = 4;
inline void RewardData::clear_status() {
  status_ = 0;
}
inline ::OpenNGS::Reward::Common::REWARDSTAT_TYPE RewardData::status() const {
  // @@protoc_insertion_point(field_get:OpenNGS.Reward.Data.RewardData.Status)
  return static_cast< ::OpenNGS::Reward::Common::REWARDSTAT_TYPE >(status_);
}
inline void RewardData::set_status(::OpenNGS::Reward::Common::REWARDSTAT_TYPE value) {
  
  status_ = value;
  // @@protoc_insertion_point(field_set:OpenNGS.Reward.Data.RewardData.Status)
}

// -------------------------------------------------------------------

// RewardDataArray

// repeated .OpenNGS.Reward.Data.RewardData items = 1;
inline int RewardDataArray::items_size() const {
  return items_.size();
}
inline void RewardDataArray::clear_items() {
  items_.Clear();
}
inline const ::OpenNGS::Reward::Data::RewardData& RewardDataArray::items(int index) const {
  // @@protoc_insertion_point(field_get:OpenNGS.Reward.Data.RewardDataArray.items)
  return items_.Get(index);
}
inline ::OpenNGS::Reward::Data::RewardData* RewardDataArray::mutable_items(int index) {
  // @@protoc_insertion_point(field_mutable:OpenNGS.Reward.Data.RewardDataArray.items)
  return items_.Mutable(index);
}
inline ::OpenNGS::Reward::Data::RewardData* RewardDataArray::add_items() {
  // @@protoc_insertion_point(field_add:OpenNGS.Reward.Data.RewardDataArray.items)
  return items_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::OpenNGS::Reward::Data::RewardData >*
RewardDataArray::mutable_items() {
  // @@protoc_insertion_point(field_mutable_list:OpenNGS.Reward.Data.RewardDataArray.items)
  return &items_;
}
inline const ::google::protobuf::RepeatedPtrField< ::OpenNGS::Reward::Data::RewardData >&
RewardDataArray::items() const {
  // @@protoc_insertion_point(field_list:OpenNGS.Reward.Data.RewardDataArray.items)
  return items_;
}

// -------------------------------------------------------------------

// RewardSaveData

// uint32 Id = 1;
inline void RewardSaveData::clear_id() {
  id_ = 0u;
}
inline ::google::protobuf::uint32 RewardSaveData::id() const {
  // @@protoc_insertion_point(field_get:OpenNGS.Reward.Data.RewardSaveData.Id)
  return id_;
}
inline void RewardSaveData::set_id(::google::protobuf::uint32 value) {
  
  id_ = value;
  // @@protoc_insertion_point(field_set:OpenNGS.Reward.Data.RewardSaveData.Id)
}

// uint32 ReceiveCount = 2;
inline void RewardSaveData::clear_receivecount() {
  receivecount_ = 0u;
}
inline ::google::protobuf::uint32 RewardSaveData::receivecount() const {
  // @@protoc_insertion_point(field_get:OpenNGS.Reward.Data.RewardSaveData.ReceiveCount)
  return receivecount_;
}
inline void RewardSaveData::set_receivecount(::google::protobuf::uint32 value) {
  
  receivecount_ = value;
  // @@protoc_insertion_point(field_set:OpenNGS.Reward.Data.RewardSaveData.ReceiveCount)
}

// -------------------------------------------------------------------

// RewardSaveDataArray

// repeated .OpenNGS.Reward.Data.RewardSaveData items = 1;
inline int RewardSaveDataArray::items_size() const {
  return items_.size();
}
inline void RewardSaveDataArray::clear_items() {
  items_.Clear();
}
inline const ::OpenNGS::Reward::Data::RewardSaveData& RewardSaveDataArray::items(int index) const {
  // @@protoc_insertion_point(field_get:OpenNGS.Reward.Data.RewardSaveDataArray.items)
  return items_.Get(index);
}
inline ::OpenNGS::Reward::Data::RewardSaveData* RewardSaveDataArray::mutable_items(int index) {
  // @@protoc_insertion_point(field_mutable:OpenNGS.Reward.Data.RewardSaveDataArray.items)
  return items_.Mutable(index);
}
inline ::OpenNGS::Reward::Data::RewardSaveData* RewardSaveDataArray::add_items() {
  // @@protoc_insertion_point(field_add:OpenNGS.Reward.Data.RewardSaveDataArray.items)
  return items_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::OpenNGS::Reward::Data::RewardSaveData >*
RewardSaveDataArray::mutable_items() {
  // @@protoc_insertion_point(field_mutable_list:OpenNGS.Reward.Data.RewardSaveDataArray.items)
  return &items_;
}
inline const ::google::protobuf::RepeatedPtrField< ::OpenNGS::Reward::Data::RewardSaveData >&
RewardSaveDataArray::items() const {
  // @@protoc_insertion_point(field_list:OpenNGS.Reward.Data.RewardSaveDataArray.items)
  return items_;
}

// -------------------------------------------------------------------

// RewardContainer

// repeated .OpenNGS.Reward.Data.RewardSaveData rewardDict = 1;
inline int RewardContainer::rewarddict_size() const {
  return rewarddict_.size();
}
inline void RewardContainer::clear_rewarddict() {
  rewarddict_.Clear();
}
inline const ::OpenNGS::Reward::Data::RewardSaveData& RewardContainer::rewarddict(int index) const {
  // @@protoc_insertion_point(field_get:OpenNGS.Reward.Data.RewardContainer.rewardDict)
  return rewarddict_.Get(index);
}
inline ::OpenNGS::Reward::Data::RewardSaveData* RewardContainer::mutable_rewarddict(int index) {
  // @@protoc_insertion_point(field_mutable:OpenNGS.Reward.Data.RewardContainer.rewardDict)
  return rewarddict_.Mutable(index);
}
inline ::OpenNGS::Reward::Data::RewardSaveData* RewardContainer::add_rewarddict() {
  // @@protoc_insertion_point(field_add:OpenNGS.Reward.Data.RewardContainer.rewardDict)
  return rewarddict_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::OpenNGS::Reward::Data::RewardSaveData >*
RewardContainer::mutable_rewarddict() {
  // @@protoc_insertion_point(field_mutable_list:OpenNGS.Reward.Data.RewardContainer.rewardDict)
  return &rewarddict_;
}
inline const ::google::protobuf::RepeatedPtrField< ::OpenNGS::Reward::Data::RewardSaveData >&
RewardContainer::rewarddict() const {
  // @@protoc_insertion_point(field_list:OpenNGS.Reward.Data.RewardContainer.rewardDict)
  return rewarddict_;
}

// -------------------------------------------------------------------

// RewardContainerArray

// repeated .OpenNGS.Reward.Data.RewardContainer items = 1;
inline int RewardContainerArray::items_size() const {
  return items_.size();
}
inline void RewardContainerArray::clear_items() {
  items_.Clear();
}
inline const ::OpenNGS::Reward::Data::RewardContainer& RewardContainerArray::items(int index) const {
  // @@protoc_insertion_point(field_get:OpenNGS.Reward.Data.RewardContainerArray.items)
  return items_.Get(index);
}
inline ::OpenNGS::Reward::Data::RewardContainer* RewardContainerArray::mutable_items(int index) {
  // @@protoc_insertion_point(field_mutable:OpenNGS.Reward.Data.RewardContainerArray.items)
  return items_.Mutable(index);
}
inline ::OpenNGS::Reward::Data::RewardContainer* RewardContainerArray::add_items() {
  // @@protoc_insertion_point(field_add:OpenNGS.Reward.Data.RewardContainerArray.items)
  return items_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::OpenNGS::Reward::Data::RewardContainer >*
RewardContainerArray::mutable_items() {
  // @@protoc_insertion_point(field_mutable_list:OpenNGS.Reward.Data.RewardContainerArray.items)
  return &items_;
}
inline const ::google::protobuf::RepeatedPtrField< ::OpenNGS::Reward::Data::RewardContainer >&
RewardContainerArray::items() const {
  // @@protoc_insertion_point(field_list:OpenNGS.Reward.Data.RewardContainerArray.items)
  return items_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace Data
}  // namespace Reward
}  // namespace OpenNGS

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_openngs_2ereward_2edata_2eproto__INCLUDED
